# How to Use This Template Repository

This is a template for starting new bioinformatics projects with reproducible, self-contained software environments.

## Quick Start

### 1. Clone this template

```bash
cd /projects/standard/GROUP/shared/ris/USER
git clone "git@github.com:umn-msi-lmnp/newproject.git" my_project_name
cd my_project_name
```

### 2. Make it your own

```bash
# Remove template git history
rm -rf .git

# Initialize as new repo
git init

# Update readme.md with your project information
# Update changelog.md with your project start date
```

### 3. Build software environments

```bash
cd software
sbatch 010_minforge.slurm  # Build miniforge (required for conda)
sbatch 011_conda1.slurm    # Build main conda (R & python) environment
sbatch 012_conda2.slurm    # Build secondary environment
```

Each script can also be run as a shell script: `bash 010_minforge.slurm`

**Note:** All SLURM scripts in this repository use robust path detection that works correctly whether run via `sbatch` or `bash`, even if you have stale SLURM environment variables from previous jobs.

### Output Directory Structure

**Key Concept:** Each build script creates a numbered output directory that matches the script name:
- `software/010_minforge.slurm` → `software_out/010_miniforge/`
- `software/011_conda1.slurm` → `software_out/011_conda1/`
- `software/021_apptainer1.slurm` → `software_out/021_apptainer1/`
- `software/031_deepvariant.slurm` → `software_out/031_deepvariant/`

**Important distinction:**
- `software_out/011_conda1/` contains **metadata** (environment exports, logs)
- `software_out/010_miniforge/miniforge/envs/conda1/` contains the **actual conda environment**

Both directories are managed together when you rebuild.

You can delete the entire `software_out/` directory and rebuild everything from scratch using the scripts in `software/`.

## Three Methods for Installing Software

This template demonstrates three methods for managing software dependencies:

### Method 1: Conda Environments (01x series)

Build custom conda environments from YAML specifications.

```bash
sbatch 010_minforge.slurm  # Build miniforge (local conda installer)
sbatch 011_conda1.slurm    # Build main (R & python) environment (tidyverse, ggplot2, etc.)
sbatch 012_conda2.slurm    # Build secondary environment (additional tools, version conflicts, etc.)
```

**When to use:**
- Use `conda1` as your main conda environment. This should include as much software as possible.
- Create additional conda environments as needed (e.g., for tools that conflict with conda1, require different versions, or for logical separation of tool sets)

**Configuration:**
- Environment specifications are defined via heredoc within each build script
- Edit the heredoc section in `software/011_conda1.slurm` to modify the main environment
- Edit the heredoc section in `software/012_conda2.slurm` to modify the secondary environment
- `software_out/010_miniforge/use_miniforge.sh` - Auto-generated activation script (created by 010_miniforge.slurm)

### Method 2: Build Custom Apptainer Containers (02x series)

Build containers from definition files for maximum reproducibility.

```bash
sbatch 021_apptainer1.slurm  # Build Picard container from apptainer1.def
```

**When to use:**
- You need tools not available in conda
- You want maximum reproducibility
- You need to share exact environments with collaborators

**Configuration files:**
- `software/apptainer1.def` - Picard container definition
- `software_out/021_apptainer1/apptainer1.sif` - Built container (created by 021_apptainer1.slurm)

### Method 3: Download Prebuilt Containers (03x series)

Download existing containers from Docker Hub or other registries.

```bash
sbatch 031_deepvariant.slurm  # Download DeepVariant from Docker Hub
```

**When to use:**
- Standard tools with official Docker images exist
- You want to use the "official" version of a tool
- You need to quickly get started without building

## Using the Environments

### Simplified Workflow: One Script to Rule Them All

**The activation script** is automatically generated when you build miniforge:
- `software_out/010_miniforge/use_miniforge.sh` (generated by `010_miniforge.slurm`)

This script:
- **NOT tracked in git** (in `.gitignore`), but is defined by the git tracked `software/010_miniforge.slurm` script
- **Regenerated every time you rebuild miniforge**
- **Initializes conda shell integration**: Enables `conda activate`, `conda deactivate`, tab completion, etc.
- **Blocks system-level Python/conda**: Ensures complete isolation from system installations
- **Prevents home directory leakage**: Blocks Python/R packages from `~/.local`, `~/R/`, `~/.Renviron`
- **Per-environment isolation**: Each conda environment has its own R configuration and package library
- **Contains absolute paths**: No confusion about which miniforge to use

When you build conda environments, activation hooks are created:
- **Conda hooks** (in `${CONDA_PREFIX}/etc/conda/activate.d/` and `deactivate.d/`): Automatically manage `LD_LIBRARY_PATH`
- **Environment-specific R configuration**: Each environment gets its own `.Renviron`, `R_libs/`, and reticulate cache

### In SLURM Scripts

Activate miniforge, then activate the conda environment you need:

**For R (conda1):**
```bash
PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
source "${PROJECT_ROOT}/software_out/010_miniforge/use_miniforge.sh"
conda activate conda1
```

**For other work (conda2):**
```bash
PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
source "${PROJECT_ROOT}/software_out/010_miniforge/use_miniforge.sh"
conda activate conda2
```

**For Apptainer containers:**
```bash
PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
CONTAINER_SIF="${PROJECT_ROOT}/software_out/021_apptainer1/apptainer1.sif"
PROJECT_REAL_PATH="$(realpath "${PROJECT_ROOT}")"
apptainer exec --bind "${PROJECT_REAL_PATH}:${PROJECT_REAL_PATH}" "${CONTAINER_SIF}" picard <command>
```

**Switching between conda environments:**

Use `conda activate` and `conda deactivate` to switch environments:

```bash
source software_out/010_miniforge/use_miniforge.sh  # Initialize conda once

conda activate conda1  # Activate conda1
# ... do R work ...

conda deactivate       # Deactivate conda1
conda activate conda2  # Switch to conda2
# ... do other work ...
```

### In RStudio Server (Open OnDemand)

The activation script works seamlessly with Open OnDemand using the standard `conda activate` method.

**Using the Custom Environment box**

When launching RStudio via Open OnDemand, put this in the "Custom Environment" box (DO NOT select a MSI module R version from the dropdown):

```bash
source /projects/standard/lmnp/knut0297/lmnp_org/newproject/software_out/010_miniforge/use_miniforge.sh && conda activate conda1
```

**Replace the path with your actual project path!**

**To verify in RStudio:**
```r
.libPaths()                    # Should show conda1 path first
library(tidyverse)             # Should load successfully
Sys.getenv("CONDA_PREFIX")     # Should show conda1 environment path
Sys.getenv("LD_LIBRARY_PATH")  # Should show conda1 library paths first
```

**Troubleshooting OOD RStudio:**
- Make sure you've built miniforge first: `sbatch software/010_miniforge.slurm`
- Make sure you've built the conda1 environment: `sbatch software/011_conda1.slurm`
- The activation script must exist: `software_out/010_miniforge/use_miniforge.sh`
- Use the **absolute path** in the Custom Environment box
- If RStudio fails to start, check the job output logs for error messages
- If packages fail to load, check that `LD_LIBRARY_PATH` is set correctly (see verification above)

## Demo Script

A single comprehensive demo script demonstrates all three software methods:

```bash
cd code
sbatch demo_analysis.slurm  # Demonstrates conda1, conda2, and apptainer1
```

This demo script showcases:
1. **conda1 environment** - Runs R (demo_analysis.R) and Python (demo_analysis.py) analyses
   - R script: 
     - Creates sample data and generates plots with ggplot2
     - Performs Seurat single-cell analysis with Leiden clustering (demonstrates R-Python integration via reticulate)
     - Generates UMAP visualization of clusters
   - Python script: Simple data analysis with pandas and numpy
2. **conda2 environment** - Demonstrates samtools functionality
3. **Apptainer container** - Runs Picard tools from apptainer1.sif

The script clearly delineates each approach and shows how to switch between environments. The Seurat analysis demonstrates how R packages can seamlessly use Python dependencies (leiden → leidenalg) within the same conda environment.

## Project Structure

```
my_project_name/
  software/                  Build scripts for environments
    010_minforge.slurm       # Method 1: Build conda (required first)
    011_conda1.slurm         # Method 1: Build R conda environment (env spec in heredoc)
    012_conda2.slurm         # Method 1: Build Python conda environment (env spec in heredoc)
    021_apptainer1.slurm     # Method 2: Build custom container
    031_deepvariant.slurm    # Method 3: Download prebuilt container
    apptainer1.def           # Picard container definition
  
  software_out/              Built software (NOT in git)
    010_miniforge/           # Output from 010_minforge.slurm
      use_miniforge.sh       # Auto-generated activation script
      miniforge/             # The miniforge installation
        envs/conda1/         # R environment (built by 011_conda1.slurm)
        envs/conda2/         # Python environment (built by 012_conda2.slurm)
    011_conda1/              # Output from 011_conda1.slurm
      env_export.yml         # Full environment snapshot
      env_export_from_history.yml
    012_conda2/              # Output from 012_conda2.slurm
      env_export.yml         # Full environment snapshot
      env_export_from_history.yml
    021_apptainer1/          # Output from 021_apptainer1.slurm
      apptainer1.sif         # Custom-built Picard container
    031_deepvariant/         # Output from 031_deepvariant.slurm
      deepvariant.sif        # Downloaded DeepVariant container
  
  .apptainer/                Apptainer build cache (NOT in git)
    cache/
    tmp/
  
  code/                      Your analysis scripts (in git)
  code_out/                  Analysis outputs (NOT in git, reproducible)
  input/                     Input data or symlinks
  meta/                      Project metadata
```

## Library Path Management (LD_LIBRARY_PATH)

Each conda environment automatically manages `LD_LIBRARY_PATH` to ensure proper library loading:

### How It Works

When you activate a conda environment (e.g., `conda activate conda1`), conda automatically runs activation scripts that:
1. Save your current `LD_LIBRARY_PATH`
2. Prepend conda environment library paths:
   - **R libraries**: `${CONDA_PREFIX}/lib/R/lib` (for R packages with compiled code)
   - **General libraries**: `${CONDA_PREFIX}/lib` (for most conda packages)
   - **GCC runtime libraries**: `${CONDA_PREFIX}/lib/gcc/x86_64-conda-linux-gnu/VERSION` (if gcc is installed)
3. Keep system paths at the end for fallback

When you deactivate or switch environments, your original `LD_LIBRARY_PATH` is automatically restored.

### Why This Matters

- **Reproducibility**: Ensures conda's libraries are used, not system libraries
- **Prevents conflicts**: Avoids mixing conda libraries with system libraries
- **R package compatibility**: R packages with compiled code (`.so` files) find the correct libraries

### Customizing Library Paths

The library path configuration is in:
```
software_out/010_miniforge/miniforge/envs/conda1/etc/conda/activate.d/env_vars.sh
software_out/010_miniforge/miniforge/envs/conda1/etc/conda/deactivate.d/env_vars.sh
```

These are regenerated each time you rebuild the environment via `sbatch software/011_conda1.slurm`.

## Self-Contained Environments

All software is installed within this project directory. **Nothing goes to your home directory.**

### Complete Isolation Strategy

The template implements comprehensive isolation to ensure reproducibility:

**Python Isolation:**
- `PYTHONPATH` is unset (prevents home directory Python packages)
- `PYTHONNOUSERSITE=1` (blocks `~/.local/lib/python*` packages)
- All Python packages come from the conda environment only

**R Isolation:**
- Each conda environment has its own `.Renviron` in `${CONDA_PREFIX}/.Renviron`
- User R packages go to `${CONDA_PREFIX}/R_libs/`, not `~/R/`
- `R_ENVIRON_USER` points to environment-specific config, not `~/.Renviron`
- No reading from `~/.Rprofile`

**Reticulate Isolation (for R packages like leiden):**
- Each conda environment has its own reticulate cache: `${CONDA_PREFIX}/.cache/reticulate/`
- `RETICULATE_PYTHON` automatically points to the active conda environment's Python
- R packages using Python (e.g., `leiden`) use the conda environment's Python and packages
- No downloading of miniconda to home directory

**Benefits of This Approach:**
- **Per-environment isolation**: conda1 and conda2 don't interfere with each other
- **No home directory contamination**: Nothing reads or writes to `~/.local`, `~/R/`, `~/.cache`
- **Reproducible**: Same environment recreates identically regardless of what's in your home directory
- **Switchable**: Can switch between conda1 and conda2 without conflicts

### Software Locations

**R packages** (from conda1):
```
software_out/010_miniforge/miniforge/envs/conda1/lib/R/library/        # Conda-installed R packages
software_out/010_miniforge/miniforge/envs/conda1/R_libs/                # User-installed R packages (install.packages)
software_out/010_miniforge/miniforge/envs/conda1/.Renviron              # Environment-specific R config
```

**Python packages** (from conda1 - for R packages like leiden):
```
software_out/010_miniforge/miniforge/envs/conda1/lib/python3.X/site-packages/
software_out/010_miniforge/miniforge/envs/conda1/.cache/reticulate/    # Reticulate cache
```

**Python packages** (from conda2):
```
software_out/010_miniforge/miniforge/envs/conda2/lib/python3.X/site-packages/
software_out/010_miniforge/miniforge/envs/conda2/R_libs/                # If conda2 has R
```

**Apptainer containers:**
```
software_out/021_apptainer1/apptainer1.sif
software_out/031_deepvariant/deepvariant.sif
```

**Apptainer cache:**
```
.apptainer/cache/
```

### Benefits

- **Portable**: Clone anywhere and rebuild identical environments
- **Reproducible**: Specific package versions in YAML/definition files, no home directory interference
- **Self-contained**: All software in project directory, not $HOME
- **Per-environment isolation**: Each conda environment is completely separate
- **No conflicts**: Independent of system-wide installations and other conda environments
- **Deletable**: Can delete `software_out/` and rebuild from scratch

### System Dependencies

Only one system-level dependency required:
- **Apptainer** (for building and running containers)

Everything else (conda, mamba, R, Python, all packages) is installed locally.

## Modifying Environments

### Rebuilding Environments

When you re-run a conda build script (e.g., `sbatch software/011_conda1.slurm`), it automatically:

1. **Renames the output directory**: `software_out/011_conda1/` → `software_out/011_conda1_DELETE_THIS_20251217-143022`
2. **Deletes the conda environment**: Removes `010_miniforge/miniforge/envs/conda1/`
3. **Rebuilds from scratch**: Creates a fresh environment with updated packages
4. **Regenerates metadata**: New activation hooks, .Renviron, and export files

The renamed directory (with `_DELETE_THIS_` suffix) can be safely deleted after verifying the new build works.

**Same behavior applies to:**
- `010_minforge.slurm` (renames `010_miniforge/`, reinstalls miniforge)
- `021_apptainer1.slurm` (renames `021_apptainer1/`, rebuilds container)
- All other software build scripts

### Adding R Packages to conda1

1. Edit the heredoc section in `software/011_conda1.slurm`
2. Add packages under `dependencies:` in the YAML heredoc
3. Rebuild: `sbatch software/011_conda1.slurm`

### Adding Python Packages to conda2

1. Edit the heredoc section in `software/012_conda2.slurm`
2. Add packages under `dependencies:` in the YAML heredoc
3. Rebuild: `sbatch software/012_conda2.slurm`

### Adding pip Packages to conda1 (R environment)

conda1 includes Python for R packages that need it (e.g., `r-leiden` needs `leidenalg`).

1. Edit the heredoc section in `software/011_conda1.slurm`
2. Add to the `pip:` section in the YAML heredoc:
   ```yaml
   dependencies:
     - r-leiden
     - python>=3.9
     - pip
     - pip:
         - leidenalg
         - another-package
   ```
3. Rebuild: `sbatch software/011_conda1.slurm`

**Why this works:**
- Conda environments ARE virtual environments
- No separate venv needed
- pip installs to conda1's isolated site-packages
- Everything stays within the project
- Fully reproducible from the build script's heredoc specification

### Modifying Containers

**For custom-built containers:**
1. Edit `software/apptainer1.def`
2. Rebuild: `sbatch software/021_apptainer1.slurm`

**For downloaded containers:**
1. Edit `software/031_deepvariant.slurm` to change version
2. Re-download: `sbatch software/031_deepvariant.slurm`

## Environment Exports (Record Keeping)

After building each conda environment, two export files are automatically created in the corresponding output directory:
- `software_out/011_conda1/env_export.yml` and `env_export_from_history.yml`
- `software_out/012_conda2/env_export.yml` and `env_export_from_history.yml`

1. **Full export** (`env_export.yml`): 
   - Complete snapshot of ALL installed packages
   - Exact versions and build strings
   - Platform-specific
   - Use to recreate exact environment

2. **History export** (`env_export_from_history.yml`):
   - Only explicitly requested packages
   - Matches the heredoc specification in the build script
   - Cross-platform
   - Use to understand intent

These are not tracked in git but are useful for:
- Debugging environment issues
- Reproducing exact environments
- Comparing environments over time
- Documentation


### What Happens When You Source the Script

1. **Conda initialization**: If conda isn't already available, the script sources the miniforge activation script
2. **Environment activation**: Runs `conda activate conda1` (or `conda2`)
3. **Automatic environment setup**: Conda automatically runs scripts in `${CONDA_PREFIX}/etc/conda/activate.d/`, which:
   - Backs up your current `LD_LIBRARY_PATH`
   - Sets `LD_LIBRARY_PATH` to prioritize conda environment libraries:
     - R libraries: `${CONDA_PREFIX}/lib/R/lib`
     - General libraries: `${CONDA_PREFIX}/lib`
     - GCC libraries: `${CONDA_PREFIX}/lib/gcc/x86_64-conda-linux-gnu/VERSION`
   - Preserves system library paths at the end

### Why LD_LIBRARY_PATH Matters

Setting `LD_LIBRARY_PATH` ensures that:
- R and other tools find the correct shared libraries (.so files)
- Conda's version of libraries are used instead of system versions
- Prevents conflicts with system-installed libraries
- Provides reproducible library loading order

### Deactivation

When you run `conda deactivate` or switch to another environment:
- The deactivation script in `${CONDA_PREFIX}/etc/conda/deactivate.d/` runs automatically
- Your original `LD_LIBRARY_PATH` is restored
- No leftover environment modifications

## Advanced Topics

### Robust SLURM Path Detection

All SLURM scripts use a `slurm_script_dir()` function that correctly determines the script's location whether run via:
- `sbatch script.slurm` (submitted as a SLURM batch job)
- `bash script.slurm` (run interactively as a shell script)
- With stale `SLURM_JOB_ID` variables in your environment

**How it works:**
1. Checks if `SLURM_SUBMIT_DIR` and `SLURM_JOB_ID` are both set
2. Queries `scontrol` to get the command path
3. Validates that the command is a real script (not "bash") and the file exists
4. Falls back to `${BASH_SOURCE[0]}` if any validation fails

This prevents issues where old SLURM environment variables from previous jobs cause scripts to use the wrong paths.

### Manual PROJECT_ROOT Override

By default, all SLURM scripts auto-detect PROJECT_ROOT using the `slurm_script_dir()` function. However, if auto-detection fails or you need to override it, you can manually set PROJECT_ROOT by adding this line at the top of any script (after the `slurm_script_dir()` function definition):

```bash
# Override auto-detection if needed
PROJECT_ROOT="/projects/standard/lmnp/knut0297/my_project"
```

This works for all scripts in `software/` and `code/` directories. The auto-detected value will be replaced with your hardcoded path.

### Per-Environment Isolation

When you activate a conda environment, the custom conda wrapper in `use_miniforge.sh` automatically sets:

```bash
# Set by conda activate wrapper
export RETICULATE_PYTHON="${CONDA_PREFIX}/bin/python"
export R_ENVIRON_USER="${CONDA_PREFIX}/.Renviron"
export R_PROFILE_USER="${CONDA_PREFIX}/.Rprofile"
export R_LIBS_USER="${CONDA_PREFIX}/R_libs"
export RETICULATE_CACHE_DIR="${CONDA_PREFIX}/.cache/reticulate"
```

When you deactivate, these are reset to prevent any environment from affecting another.

### R Packages with Python Dependencies (e.g., leiden)

The conda1 environment includes both R and Python, allowing R packages that depend on Python to work seamlessly:

**Setup in `software/011_conda1.slurm`:**
```yaml
dependencies:
  - r-base=4.4.0
  - r-seurat>=5
  - r-leiden          # R package
  - r-reticulate      # R-Python interface
  - python>=3.9
  - pip:
    - leidenalg       # Python package needed by r-leiden
```

**Automatic configuration in R scripts:**
```r
# At the start of Seurat analysis
library(reticulate)
reticulate_python <- Sys.getenv("RETICULATE_PYTHON")
if (reticulate_python != "") {
    use_python(reticulate_python, required = TRUE)
}
```

This ensures R's `leiden` package uses the conda environment's `leidenalg`, not anything from your home directory.

## Troubleshooting

### Scripts fail with path errors

All scripts auto-detect PROJECT_ROOT using the `slurm_script_dir()` function. If auto-detection fails:

1. Verify the `slurm_script_dir()` function is present in the script
2. Manually set PROJECT_ROOT (see "Manual PROJECT_ROOT Override" in Advanced Topics)
3. Check that you're running the script from the correct location

### Environment rebuild doesn't remove old packages

The build scripts automatically delete and rebuild conda environments. If this doesn't happen:

1. Check the build log for errors (`.e` and `.o` files in the software directory)
2. Verify the environment exists: `conda env list`
3. Manually remove if needed: `conda env remove -n conda1`
4. Re-run the build script

### Open OnDemand RStudio fails to start

Common issues and solutions:

1. **Miniforge not built**: Verify `software_out/010_miniforge/use_miniforge.sh` exists
2. **Conda environment not built**: Check `ls software_out/010_miniforge/miniforge/envs/conda1`
3. **Wrong path**: Use absolute path in Custom Environment box (not relative)
4. **Environment variables**: Check RStudio job logs for error messages

To verify environment in RStudio:
```r
.libPaths()                    # Should show conda1 path first
Sys.getenv("CONDA_PREFIX")     # Should show conda1 environment path
Sys.getenv("LD_LIBRARY_PATH")  # Should show conda1 library paths first
```

### Packages fail to load or wrong versions used

This usually indicates home directory interference:

1. Check for `~/.Renviron` or `~/.Rprofile` that might override settings
2. Verify `R_ENVIRON_USER` points to conda environment: `Sys.getenv("R_ENVIRON_USER")`
3. Check Python isolation: `python -c "import sys; print(sys.path)"`
4. Rebuild the environment to regenerate all isolation settings

### Container builds fail

For Apptainer containers:

1. Verify Apptainer is available: `apptainer --version`
2. Check cache directories exist and have space: `ls .apptainer/cache`
3. Review the container definition file syntax
4. Check the build log for specific errors

## Key Features

- **Portable**: Uses absolute paths in generated scripts. Clone anywhere and rebuild.
- **Reproducible**: Specific package versions in configuration files, isolated from home directory.
- **No modules needed**: Self-contained conda environments.
- **Easy to use**: Single-line activation in scripts.
- **Self-contained**: All software stays in project directory, not $HOME.
- **Complete isolation**: Blocks home directory packages, per-environment R configuration.
- **Automatic library management**: `LD_LIBRARY_PATH` is set/restored automatically on activate/deactivate.
- **Robust path detection**: Scripts work correctly with or without SLURM, even with stale environment variables.
- **OOD-compatible**: Works seamlessly with Open OnDemand RStudio.
- **Three methods**: Conda, custom containers, or downloaded containers.

## Naming Conventions

### Software Build Scripts (software/ directory)

- **01x**: Conda environments
  - `010_minforge.slurm` - Build miniforge
  - `011_conda1.slurm` - Build conda environment 1
  - `012_conda2.slurm` - Build conda environment 2

- **02x**: Custom Apptainer containers (built from .def files)
  - `021_apptainer1.slurm` - Build custom container 1
  - `022_apptainer2.slurm` - Build custom container 2

- **03x**: Downloaded containers (from registries)
  - `031_deepvariant.slurm` - Download container 1
  - `032_another.slurm` - Download container 2

### Demo Scripts (code/ directory)

A single consolidated demo script demonstrates all software methods:
- `demo_analysis.slurm` - Demonstrates conda1 (R & Python), conda2 (samtools), and apptainer1 (Picard)
- `demo_analysis.R` - R analysis script (called by demo_analysis.slurm)
- `demo_analysis.py` - Python analysis script (called by demo_analysis.slurm)

