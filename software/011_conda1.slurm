#!/bin/env bash
#SBATCH --nodes=1
#SBATCH --ntasks-per-node=1
#SBATCH --cpus-per-task=8
#SBATCH --time=4:00:00
#SBATCH --mem=32gb
#SBATCH --tmp=8gb
#SBATCH --error=%x.e%j
#SBATCH --output=%x.o%j
#SBATCH --export=MSIPROJECT
#SBATCH --mail-type=FAIL
#SBATCH --partition=msismall

set -euo pipefail

# Get project root and setup paths
if [ -n "${SLURM_SUBMIT_DIR:-}" ]; then
    # Running via SLURM - use submit directory
    PROJECT_ROOT="$(cd "${SLURM_SUBMIT_DIR}/.." && pwd)"
else
    # Running interactively - use script location
    PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
fi

# Path to miniforge (installed by 010_miniforge.slurm)
MINIFORGE_DIR="${PROJECT_ROOT}/software_out/010_miniforge/miniforge"

# Output directory matching this script's name
OUTPUT_DIR="${PROJECT_ROOT}/software_out/011_conda1"

# Input files
ENV_FILE="${PROJECT_ROOT}/software/conda1.yml"

# Rename existing output directory if it exists
if [ -d "${OUTPUT_DIR}" ]; then
    TIMESTAMP=$(date +%Y%m%d-%H%M%S)
    OLD_DIR="${PROJECT_ROOT}/software_out/011_conda1_DELETE_THIS_${TIMESTAMP}"
    echo "Existing output directory found. Renaming to: 011_conda1_DELETE_THIS_${TIMESTAMP}"
    mv "${OUTPUT_DIR}" "${OLD_DIR}"
fi

# Create output directory
mkdir -p "${OUTPUT_DIR}"

# Force conda to use project-local paths only (not $HOME/.conda)
export CONDARC="${MINIFORGE_DIR}/.condarc"

# Activate miniforge
source "${MINIFORGE_DIR}/bin/activate"

# Check if environment already exists
ENV_EXISTS=$(conda env list | grep -c "^conda1 " || true)

if [ "$ENV_EXISTS" -gt 0 ]; then
    # Check if running with TTY (interactive) or not
    if [ -t 0 ]; then
        # Running interactively - prompt for confirmation
        echo "Environment conda1 already exists."
        read -p "Do you want to delete and rebuild it? (yes/no): " response
        if [ "$response" = "yes" ]; then
            echo "Removing environment conda1..."
            mamba env remove -n conda1 -y
        else
            echo "Aborting. Environment not modified."
            exit 0
        fi
    else
        # Running non-interactively - automatically remove and rebuild
        echo "Environment conda1 already exists. Running non-interactively - automatically removing and rebuilding..."
        mamba env remove -n conda1 -y
    fi
fi

echo "Building conda environment: conda1"
mamba env create -f "${ENV_FILE}"

echo "Done! Environment conda1 is ready."

# Create conda activation/deactivation scripts for LD_LIBRARY_PATH
echo "Creating conda activation/deactivation scripts..."
CONDA1_PREFIX="${MINIFORGE_DIR}/envs/conda1"

# Detect gcc version dynamically
GCC_VERSION=$(ls -d "${CONDA1_PREFIX}/lib/gcc/x86_64-conda-linux-gnu"/* 2>/dev/null | head -1 | xargs basename)
if [ -z "$GCC_VERSION" ]; then
    echo "Warning: gcc not found in conda1, skipping gcc library path"
    GCC_LIB_PATH=""
else
    echo "Detected gcc version: $GCC_VERSION"
    GCC_LIB_PATH="${CONDA1_PREFIX}/lib/gcc/x86_64-conda-linux-gnu/${GCC_VERSION}:"
fi

# Create activate.d directory and script
mkdir -p "${CONDA1_PREFIX}/etc/conda/activate.d"
cat > "${CONDA1_PREFIX}/etc/conda/activate.d/env_vars.sh" << EOF
#!/bin/sh

# Save the current LD_LIBRARY_PATH so we can restore it on deactivate
export LD_LIBRARY_PATH_BACKUP="\${LD_LIBRARY_PATH:-}"

# Add conda environment library paths
# Priority order: R libs, general libs, gcc libs, then system
export LD_LIBRARY_PATH="\${CONDA_PREFIX}/lib/R/lib:\${CONDA_PREFIX}/lib:${GCC_LIB_PATH}\${LD_LIBRARY_PATH}"
EOF

chmod +x "${CONDA1_PREFIX}/etc/conda/activate.d/env_vars.sh"

# Create deactivate.d directory and script
mkdir -p "${CONDA1_PREFIX}/etc/conda/deactivate.d"
cat > "${CONDA1_PREFIX}/etc/conda/deactivate.d/env_vars.sh" << 'EOF'
#!/bin/sh

# Restore the original LD_LIBRARY_PATH
export LD_LIBRARY_PATH="${LD_LIBRARY_PATH_BACKUP}"
unset LD_LIBRARY_PATH_BACKUP
EOF

chmod +x "${CONDA1_PREFIX}/etc/conda/deactivate.d/env_vars.sh"

echo "Conda activation/deactivation scripts created."

# Export environment specifications for record keeping
echo "Exporting environment specification for record keeping..."
conda env export -n conda1 > "${OUTPUT_DIR}/env_export.yml"
conda env export --from-history -n conda1 > "${OUTPUT_DIR}/env_export_from_history.yml"

echo "Environment exports saved to ${OUTPUT_DIR}/"

# Generate activation script with absolute paths
echo "Generating activation script..."
cat > "${OUTPUT_DIR}/use_conda1.sh" << 'ACTIVATION_SCRIPT'
#!/bin/bash
# Auto-generated activation script for conda1 environment
# Generated by: software/011_conda1.slurm
# DO NOT EDIT MANUALLY - will be regenerated when environment is rebuilt
#
# Usage:
#   source SOFTWARE_BUILD_DIR/use_conda1.sh
#
# This script works in all contexts including:
#   - SLURM jobs
#   - Interactive terminals
#   - Open OnDemand RStudio

# Absolute paths (generated at build time)
PROJECT_ROOT="PROJECT_ROOT_PLACEHOLDER"
MINIFORGE_DIR="${PROJECT_ROOT}/software_out/010_miniforge/miniforge"

# Force conda to use project-local paths only (not $HOME/.conda)
export CONDARC="${MINIFORGE_DIR}/.condarc"

# Tell reticulate which Python to use (prevents leiden from trying to create r-reticulate)
export RETICULATE_PYTHON="${MINIFORGE_DIR}/envs/conda1/bin/python"

# Prevent R from saving/restoring workspace
export R_SAVE_IMAGE=no
export R_RESTORE_HISTORY=no

# Initialize conda if not already available
if ! command -v conda &> /dev/null; then
    source "${MINIFORGE_DIR}/bin/activate"
fi

# Activate conda1 environment
# This will automatically run the activation scripts in:
#   ${CONDA_PREFIX}/etc/conda/activate.d/env_vars.sh
# which sets LD_LIBRARY_PATH appropriately
conda activate conda1

echo "Activated conda environment: conda1"
ACTIVATION_SCRIPT

# Replace placeholder with actual project root
sed -i "s|PROJECT_ROOT_PLACEHOLDER|${PROJECT_ROOT}|g" "${OUTPUT_DIR}/use_conda1.sh"

chmod +x "${OUTPUT_DIR}/use_conda1.sh"
echo "Activation script created at: ${OUTPUT_DIR}/use_conda1.sh"
echo ""
echo "Done! All conda1 outputs are in ${OUTPUT_DIR}/"
