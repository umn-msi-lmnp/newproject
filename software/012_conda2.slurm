#!/bin/env bash
#SBATCH --nodes=1
#SBATCH --ntasks-per-node=1
#SBATCH --cpus-per-task=8
#SBATCH --time=4:00:00
#SBATCH --mem=32gb
#SBATCH --tmp=8gb
#SBATCH --error=%x.e%j
#SBATCH --output=%x.o%j
#SBATCH --export=MSIPROJECT
#SBATCH --mail-type=FAIL
#SBATCH --partition=msismall

set -euo pipefail

# Get project root and setup paths
if [ -n "${SLURM_SUBMIT_DIR:-}" ]; then
    # Running via SLURM - use submit directory
    PROJECT_ROOT="$(cd "${SLURM_SUBMIT_DIR}/.." && pwd)"
else
    # Running interactively - use script location
    PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
fi

# Path to miniforge (installed by 010_miniforge.slurm)
MINIFORGE_DIR="${PROJECT_ROOT}/software_out/010_miniforge/miniforge"

# Output directory matching this script's name
OUTPUT_DIR="${PROJECT_ROOT}/software_out/012_conda2"

# Input files
ENV_FILE="${PROJECT_ROOT}/software/conda2.yml"

# Rename existing output directory if it exists
if [ -d "${OUTPUT_DIR}" ]; then
    TIMESTAMP=$(date +%Y%m%d-%H%M%S)
    OLD_DIR="${PROJECT_ROOT}/software_out/012_conda2_DELETE_THIS_${TIMESTAMP}"
    echo "Existing output directory found. Renaming to: 012_conda2_DELETE_THIS_${TIMESTAMP}"
    mv "${OUTPUT_DIR}" "${OLD_DIR}"
fi

# Create output directory
mkdir -p "${OUTPUT_DIR}"

# Force conda to use project-local paths only (not $HOME/.conda)
export CONDARC="${MINIFORGE_DIR}/.condarc"

# Activate miniforge
source "${MINIFORGE_DIR}/bin/activate"

# Check if environment already exists
ENV_EXISTS=$(conda env list | grep -c "^conda2 " || true)

if [ "$ENV_EXISTS" -gt 0 ]; then
    # Check if running with TTY (interactive) or not
    if [ -t 0 ]; then
        # Running interactively - prompt for confirmation
        echo "Environment conda2 already exists."
        read -p "Do you want to delete and rebuild it? (yes/no): " response
        if [ "$response" = "yes" ]; then
            echo "Removing environment conda2..."
            mamba env remove -n conda2 -y
        else
            echo "Aborting. Environment not modified."
            exit 0
        fi
    else
        # Running non-interactively - automatically remove and rebuild
        echo "Environment conda2 already exists. Running non-interactively - automatically removing and rebuilding..."
        mamba env remove -n conda2 -y
    fi
fi

echo "Building conda environment: conda2"
mamba env create -f "${ENV_FILE}"

echo "Done! Environment conda2 is ready."

# Create conda activation/deactivation scripts for LD_LIBRARY_PATH
echo "Creating conda activation/deactivation scripts..."
CONDA2_PREFIX="${MINIFORGE_DIR}/envs/conda2"

# Detect gcc version dynamically
GCC_VERSION=$(ls -d "${CONDA2_PREFIX}/lib/gcc/x86_64-conda-linux-gnu"/* 2>/dev/null | head -1 | xargs basename)
if [ -z "$GCC_VERSION" ]; then
    echo "Note: gcc not found in conda2, skipping gcc library path"
    GCC_LIB_PATH=""
else
    echo "Detected gcc version: $GCC_VERSION"
    GCC_LIB_PATH="${CONDA2_PREFIX}/lib/gcc/x86_64-conda-linux-gnu/${GCC_VERSION}:"
fi

# Create activate.d directory and script
mkdir -p "${CONDA2_PREFIX}/etc/conda/activate.d"
cat > "${CONDA2_PREFIX}/etc/conda/activate.d/env_vars.sh" << EOF
#!/bin/sh

# Save the current LD_LIBRARY_PATH so we can restore it on deactivate
export LD_LIBRARY_PATH_BACKUP="\${LD_LIBRARY_PATH:-}"

# Add conda environment library paths
# Priority order: R libs (if present), general libs, gcc libs (if present), then system
if [ -d "\${CONDA_PREFIX}/lib/R/lib" ]; then
    export LD_LIBRARY_PATH="\${CONDA_PREFIX}/lib/R/lib:\${CONDA_PREFIX}/lib:${GCC_LIB_PATH}\${LD_LIBRARY_PATH}"
else
    export LD_LIBRARY_PATH="\${CONDA_PREFIX}/lib:${GCC_LIB_PATH}\${LD_LIBRARY_PATH}"
fi
EOF

chmod +x "${CONDA2_PREFIX}/etc/conda/activate.d/env_vars.sh"

# Create deactivate.d directory and script
mkdir -p "${CONDA2_PREFIX}/etc/conda/deactivate.d"
cat > "${CONDA2_PREFIX}/etc/conda/deactivate.d/env_vars.sh" << 'EOF'
#!/bin/sh

# Restore the original LD_LIBRARY_PATH
export LD_LIBRARY_PATH="${LD_LIBRARY_PATH_BACKUP}"
unset LD_LIBRARY_PATH_BACKUP
EOF

chmod +x "${CONDA2_PREFIX}/etc/conda/deactivate.d/env_vars.sh"

echo "Conda activation/deactivation scripts created."

# Export environment specifications for record keeping
echo "Exporting environment specification for record keeping..."
conda env export -n conda2 > "${OUTPUT_DIR}/env_export.yml"
conda env export --from-history -n conda2 > "${OUTPUT_DIR}/env_export_from_history.yml"

echo "Environment exports saved to ${OUTPUT_DIR}/"

# Generate activation script with absolute paths
echo "Generating activation script..."
cat > "${OUTPUT_DIR}/use_conda2.sh" << 'ACTIVATION_SCRIPT'
#!/bin/bash
# Auto-generated activation script for conda2 environment
# Generated by: software/012_conda2.slurm
# DO NOT EDIT MANUALLY - will be regenerated when environment is rebuilt
#
# Usage:
#   source SOFTWARE_BUILD_DIR/use_conda2.sh
#
# This script works in all contexts including:
#   - SLURM jobs
#   - Interactive terminals
#   - Open OnDemand RStudio

# Absolute paths (generated at build time)
PROJECT_ROOT="PROJECT_ROOT_PLACEHOLDER"
MINIFORGE_DIR="${PROJECT_ROOT}/software_out/010_miniforge/miniforge"

# Force conda to use project-local paths only (not $HOME/.conda)
export CONDARC="${MINIFORGE_DIR}/.condarc"

# Initialize conda if not already available
if ! command -v conda &> /dev/null; then
    source "${MINIFORGE_DIR}/bin/activate"
fi

# Activate conda2 environment
# This will automatically run the activation scripts in:
#   ${CONDA_PREFIX}/etc/conda/activate.d/env_vars.sh
# which sets LD_LIBRARY_PATH appropriately
conda activate conda2

echo "Activated conda environment: conda2"
ACTIVATION_SCRIPT

# Replace placeholder with actual project root
sed -i "s|PROJECT_ROOT_PLACEHOLDER|${PROJECT_ROOT}|g" "${OUTPUT_DIR}/use_conda2.sh"

chmod +x "${OUTPUT_DIR}/use_conda2.sh"
echo "Activation script created at: ${OUTPUT_DIR}/use_conda2.sh"
echo ""
echo "Done! All conda2 outputs are in ${OUTPUT_DIR}/"
