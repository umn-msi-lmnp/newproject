#!/bin/env bash
#SBATCH --nodes=1
#SBATCH --ntasks-per-node=1
#SBATCH --cpus-per-task=8
#SBATCH --time=4:00:00
#SBATCH --mem=32gb
#SBATCH --tmp=8gb
#SBATCH --error=%x.e%j
#SBATCH --output=%x.o%j
#SBATCH --export=NONE
#SBATCH --mail-type=FAIL
#SBATCH --partition=msismall

set -euo pipefail

# Function to reliably get script directory
slurm_script_dir() {
  local script_path
  if [[ -n "${SLURM_JOB_ID-}" ]]; then
    script_path="$(scontrol show job "$SLURM_JOB_ID" -o | sed -n 's/.*Command=\([^ ]*\).*/\1/p')"
  else
    script_path="${BASH_SOURCE[0]}"
  fi
  script_path="$(readlink -f "$script_path")"
  dirname "$script_path"
}

# Get project root and setup paths
# Since script is in PROJECT_ROOT/software/, get parent directory
SCRIPT_DIR="$(slurm_script_dir)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Output directory matching this script's name
OUTPUT_DIR="${PROJECT_ROOT}/software_out/010_miniforge"
INSTALL_DIR="${OUTPUT_DIR}/miniforge"
MINIFORGE_VERSION="24.7.1-0"

echo "Installing Miniforge to ${INSTALL_DIR}"

# Rename existing output directory if it exists
if [ -d "${OUTPUT_DIR}" ]; then
    TIMESTAMP=$(date +%Y%m%d-%H%M%S)
    OLD_DIR="${PROJECT_ROOT}/software_out/010_miniforge_DELETE_THIS_${TIMESTAMP}"
    echo "Existing output directory found. Renaming to: 010_miniforge_DELETE_THIS_${TIMESTAMP}"
    mv "${OUTPUT_DIR}" "${OLD_DIR}"
fi

# Create output directory
mkdir -p "${OUTPUT_DIR}"

# Download and install if not already present
if [ ! -d "${INSTALL_DIR}" ]; then
    cd "${OUTPUT_DIR}"
    
    echo "Downloading Miniforge..."
    INSTALLER="Miniforge3-${MINIFORGE_VERSION}-Linux-x86_64.sh"
    wget -q "https://github.com/conda-forge/miniforge/releases/download/${MINIFORGE_VERSION}/${INSTALLER}"
    
    # ---------------------------------------------------------------------
    # Remove the check on free disk space
    # ---------------------------------------------------------------------
    # panasas does not report the correct values when using the "df" command, and miniforge uses this
    # command to determine if there is enough space to install the tool. It errors out if it fails 
    # this check. Therefore, we remove this check.
    echo "Modifying installer to remove disk space check..."
    INSTALLER_MODIFIED="${INSTALLER%.sh}_modified.sh"
    sed '/^if \[ "$free_disk_space_kb_with_buffer"/,/^fi/ s/^/#/' "${INSTALLER}" >"${INSTALLER_MODIFIED}"
    
    # ---------------------------------------------------------------------
    # Run the installer
    # ---------------------------------------------------------------------
    echo "Installing Miniforge..."
    bash --login "${INSTALLER_MODIFIED}" -b -p "${INSTALL_DIR}"
    
    echo "Cleaning up installer..."
    rm "${INSTALLER}" "${INSTALLER_MODIFIED}"
    
    echo "Configuring conda to use project-local paths only..."
    cat > "${INSTALL_DIR}/.condarc" << CONDARC
channels:
  - conda-forge

envs_dirs:
  - ${INSTALL_DIR}/envs

pkgs_dirs:
  - ${INSTALL_DIR}/pkgs
CONDARC
    
    echo "Miniforge installed successfully!"
else
    echo "Miniforge already installed at ${INSTALL_DIR}"
fi

# Create a local .conda directory to prevent reading from ~/.conda
mkdir -p "${INSTALL_DIR}/.conda"
touch "${INSTALL_DIR}/.conda/environments.txt"


# ---------------------------------------------------------------------
# Create a shell script to initialize conda in the current shell
# ---------------------------------------------------------------------

echo "Generating activation script..."
cat > "${OUTPUT_DIR}/use_miniforge.sh" << 'ACTIVATION_SCRIPT'
#!/bin/env bash
# Auto-generated activation script for miniforge
# Generated by: software/010_miniforge.slurm
# DO NOT EDIT MANUALLY - will be regenerated when miniforge is rebuilt
#
# PLEASE NOTE:
# The code below is generally managed by conda init. Conda suggests running "conda init", which writes these lines to your
# bashrc file. That causes every shell you open to add this version of conda to your PATH and adds various conda helper functions
# to your shell environment.
#
# However, we work in HPC environments, and each user may not want to have conda installed in every shell they open.
# Instead, when we want conda available, we source this script in the shell we want to use conda in.
#
# This results in this shell being configured exactly as conda would normally do it (via bashrc). But it does not affect
# all your other shells, only this particular shell.

# ---------------------------------------------------------------------
# Check if script is being sourced or executed
# ---------------------------------------------------------------------
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    echo "ERROR: This script must be sourced, not executed directly."
    echo ""
    echo "Usage:"
    echo "  source ${BASH_SOURCE[0]}"
    echo ""
    echo "Or:"
    echo "  . ${BASH_SOURCE[0]}"
    echo ""
    echo "Do NOT run it as:"
    echo "  ./${BASH_SOURCE[0]##*/}  # WRONG!"
    echo "  bash ${BASH_SOURCE[0]##*/}  # WRONG!"
    echo ""
    echo "Explanation:"
    echo "  This script modifies your current shell environment (PATH, conda functions, etc.)."
    echo "  Executing it directly creates a subshell that exits immediately, losing all changes."
    echo "  Sourcing it runs the commands in your current shell, preserving the environment."
    exit 1
fi

# Absolute paths (generated at build time)
PROJECT_ROOT="PROJECT_ROOT_PLACEHOLDER"
MINIFORGE_DIR="${PROJECT_ROOT}/software_out/010_miniforge/miniforge"

# ---------------------------------------------------------------------
# Block system-level conda/python to ensure isolation
# ---------------------------------------------------------------------

# Unset conda-related environment variables from other installations
unset CONDA_EXE CONDA_PREFIX CONDA_PYTHON_EXE CONDA_SHLVL CONDA_DEFAULT_ENV
unset CONDA_PROMPT_MODIFIER _CE_CONDA _CE_M

# Prevent conda from using user home directory
unset CONDA_ENVS_PATH CONDA_PKGS_DIRS

# ---------------------------------------------------------------------
# Set up miniforge environment variables for complete isolation
# ---------------------------------------------------------------------

# Override ALL conda configuration paths by setting explicit environment variables BEFORE conda initializes
# These take precedence over any .condarc files (including ~/.condarc)
export CONDA_ENVS_DIRS="${MINIFORGE_DIR}/envs"
export CONDA_PKGS_DIRS="${MINIFORGE_DIR}/pkgs"

# Force conda to use project-local .condarc only (not $HOME/.conda or ~/.condarc)
export CONDARC="${MINIFORGE_DIR}/.condarc"

# Set SSL certificate path for conda
export CONDA_SSL_VERIFY="${MINIFORGE_DIR}/ssl/cacert.pem"

# Prevent conda from tracking envs in ~/.conda/environments.txt
# By setting CONDA_USER_BASE, we prevent conda from reading/writing to HOME directory
export CONDA_ROOT="${MINIFORGE_DIR}"
export CONDA_USER_BASE="${MINIFORGE_DIR}"

# ---------------------------------------------------------------------
# >>> conda initialize >>>
# !! Contents within this block are managed by 'conda init' !!
# ---------------------------------------------------------------------

__conda_setup="$('${MINIFORGE_DIR}/bin/conda' 'shell.bash' 'hook' 2> /dev/null)"
if [ $? -eq 0 ]; then
    eval "$__conda_setup"
else
    if [ -f "${MINIFORGE_DIR}/etc/profile.d/conda.sh" ]; then
        . "${MINIFORGE_DIR}/etc/profile.d/conda.sh"
    else
        export PATH="${MINIFORGE_DIR}/bin:$PATH"
    fi
fi
unset __conda_setup

if [ -f "${MINIFORGE_DIR}/etc/profile.d/mamba.sh" ]; then
    . "${MINIFORGE_DIR}/etc/profile.d/mamba.sh"
fi

# ---------------------------------------------------------------------
# <<< conda initialize <<<
# ---------------------------------------------------------------------

# ---------------------------------------------------------------------
# Force complete isolation from HOME directory conda after initialization
# ---------------------------------------------------------------------

# Re-export these after conda init to ensure they override conda's defaults
# This prevents conda from looking in ~/.conda/envs or reading ~/.conda/environments.txt
export CONDA_ENVS_DIRS="${MINIFORGE_DIR}/envs"
export CONDA_PKGS_DIRS="${MINIFORGE_DIR}/pkgs"

# ---------------------------------------------------------------------
# Make miniforge base tools available immediately
# ---------------------------------------------------------------------
# Add miniforge bin to PATH so python, mamba, etc. are immediately available
# This does NOT activate the base environment, just makes tools accessible
# When you activate a specific env (e.g., conda1), that env's bin will take precedence
export PATH="${MINIFORGE_DIR}/bin:${PATH}"

# Create a wrapper to filter conda env list output
# This is necessary because conda reads ~/.conda/environments.txt regardless of our settings
# We save the original conda function and wrap it carefully
_original_conda_function="$(declare -f conda)"
eval "$(echo "${_original_conda_function}" | sed 's/conda ()/__original_conda ()/')"

conda() {
    if [ "$1" = "env" ] && [ "$2" = "list" ]; then
        # Show only header and environments in this repo
        __original_conda env list | grep "^#"
        __original_conda env list | grep -v "^#" | grep "${MINIFORGE_DIR}" || true
    else
        # Pass through all other conda commands to the original function
        __original_conda "$@"
    fi
}

# Print a message to the shell
printf "\n"
printf "%s\n" "----------------------------------"
printf "PLEASE NOTE: This shell has been configured to run conda (and mamba).\n\n"
printf "Project root: %s\n" "${PROJECT_ROOT}"
printf "Miniforge installation: %s\n\n" "${MINIFORGE_DIR}"
printf "Python/conda status:\n"
printf "  python, mamba, conda commands are now available (from miniforge base)\n"
printf "  No conda environment is active yet (CONDA_PREFIX is not set)\n"
printf "  To get environment-specific packages, activate an environment:\n"
printf "    conda activate conda1  # or conda2\n\n"
printf "To stop using this version of these tools, exit the shell:\n"
printf "exit\n\n"
printf "Useful commands:\n"
printf "conda env list                   # List conda environments available to you\n"
printf "conda activate ENV               # Activate an env by name\n"
printf "conda deactivate                 # Deactivate your current conda env\n"
printf "mamba create -n MYNAME MYTOOL    # Create a new env, using the faster 'mamba' solver\n\n"
printf "Available environments:\n"
conda env list | grep -v "^#" | tail -n +2 || printf "  No environments created yet\n"
printf "\nQuick start:\n"
printf "conda activate conda1  # Activate the main R & Python environment\n"
printf "conda activate conda2  # Activate the secondary environment\n"
printf "%s\n\n" "----------------------------------"
ACTIVATION_SCRIPT

# Replace placeholder with actual project root
sed -i "s|PROJECT_ROOT_PLACEHOLDER|${PROJECT_ROOT}|g" "${OUTPUT_DIR}/use_miniforge.sh"

chmod +x "${OUTPUT_DIR}/use_miniforge.sh"
echo "Activation script created at: ${OUTPUT_DIR}/use_miniforge.sh"
echo ""
echo "Done! Miniforge output is in ${OUTPUT_DIR}/"
